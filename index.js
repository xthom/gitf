// Generated by CoffeeScript 1.6.3
(function() {
  var argv, async, callback, colors, config, ensureBranch, exec, getCurrentBranch, git, printUsage, runTask, task, tasks,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exec = require("child_process").exec;

  argv = require("minimist")(process.argv.slice(2));

  colors = require("colors");

  async = require("async");

  config = {
    local: {
      rootBranch: "master"
    },
    remote: {
      repository: "origin",
      rootBranch: "master"
    },
    install: {
      url: "https://raw.github.com/xthom/gitf/latest/bin/install"
    }
  };

  git = function(cmd, cb) {
    return exec("git " + cmd, {
      cwd: process.cwd()
    }, function(err, stdout, stderr) {
      if (err) {
        return cb(err);
      }
      return cb(null, (stdout != null ? stdout : stderr).trim());
    });
  };

  printUsage = function(args, cb) {
    console.log("Usage:\n\t " + "gitf <task> [<subtask>|<branch_name>] [options]".bold + "\n\nTasks:\n\t " + "start".bold + "    creates a new branch based on master,\n\t          parameter <branch_name> is required\n\t " + "publish".bold + "  publishes the current branch (or given branch) to \n\t          tracked origin\n\t " + "update".bold + "   updates current or given branch with changes from \n\t          master (via merge)\n\t " + "finish".bold + "   merges current or given branch to master, creates \n\t          new tag and deletes the branch\n\t " + "config".bold + "   configuration tools \n\nSubtask:\n\t " + "update".bold + "   in use with " + "gitf config".bold + " will update the gitf program\n\t          to its latest version\n\nOptions:\n\t " + "--tag [<tag>]".bold + "\n\t " + "--no-tag".bold + " enables, disables, or sets the tag for " + "gitf finish".bold + " task,\n\t          the user is prompted to enter tag by default\n");
  };

  ensureBranch = function(branchName, cb) {
    return git("checkout " + branchName, function(err) {
      if (err) {
        return cb(err);
      }
      console.log("Checked out " + branchName);
      return cb(null, branchName);
    });
  };

  getCurrentBranch = function(cb) {
    return git("symbolic-ref HEAD 2>/dev/null | cut -d\"/\" -f 3", cb);
  };

  tasks = {};

  task = function(taskName, cb) {
    return tasks[taskName] = cb;
  };

  /*
    gitf start <branch>
  */


  task("start", function(args, cb) {
    var newBranch, syncTasks;
    console.log("Starting new branch...".bold);
    newBranch = args._.shift();
    if (!newBranch) {
      return cb("Enter the name of branch to open");
    }
    syncTasks = [];
    syncTasks.push(function(next) {
      return ensureBranch(config.local.rootBranch, next);
    });
    syncTasks.push(function(next) {
      return git("checkout -b " + newBranch, function(err) {
        if (err) {
          return next(err);
        }
        console.log("Created new branch \"" + newBranch + "\"");
        return next();
      });
    });
    syncTasks.push(function(next) {
      console.log("Done.\n");
      console.log("Now:\n* you can " + "commit".bold + " and " + "publish".bold + " your changes with " + "gitf publish".bold + " to " + config.remote.repository + ", \n* or update your current branch from " + config.local.rootBranch + " with " + "gitf update".bold + ". \n");
      return next();
    });
    return async.series(syncTasks, cb);
  });

  /*
    gitf publish [<branch>]
  */


  task("publish", function(args, cb) {
    var syncTasks;
    syncTasks = [];
    syncTasks.push(function(next) {
      var branch;
      branch = args._.shift();
      return next(null, branch);
    });
    syncTasks.push(function(branch, next) {
      if (!branch) {
        return getCurrentBranch(next);
      }
      return next(null, branch);
    });
    syncTasks.push(function(branch, next) {
      if (!branch) {
        return next("Cannot determine git branch - maybe not in a git repository");
      }
      console.log(("Publishing branch \"" + branch + "\"...").bold);
      return next(null, branch);
    });
    syncTasks.push(ensureBranch);
    syncTasks.push(function(branch, next) {
      return git("push " + config.remote.repository + " " + branch, function(err, data) {
        return next(err, branch);
      });
    });
    syncTasks.push(function(branch, next) {
      console.log("Done. Branch " + branch + " published to " + config.remote.repository + "/" + branch + ".");
      return next();
    });
    return async.waterfall(syncTasks, cb);
  });

  /*
    gitf finish [<branch>]
  */


  task("finish", function(args, cb) {
    var syncTasks;
    syncTasks = [];
    syncTasks.push(function(next) {
      var branch;
      branch = args._.shift();
      return next(null, branch);
    });
    syncTasks.push(function(branch, next) {
      if (!branch) {
        return getCurrentBranch(next);
      }
      return next(null, branch);
    });
    syncTasks.push(function(branch, next) {
      if (!branch) {
        return next("Cannot determine git branch - maybe not in a git repository");
      }
      console.log(("Finishing branch \"" + branch + "\"...").bold);
      if (branch === config.local.rootBranch) {
        return next("Cannot perform finish on root branch " + branch);
      }
      return next(null, branch);
    });
    syncTasks.push(function(branch, next) {
      return ensureBranch(config.local.rootBranch, function(err) {
        return next(err, branch);
      });
    });
    syncTasks.push(function(branch, next) {
      return git("merge --no-ff --no-edit " + branch, function(err) {
        if (!err) {
          console.log("Branch " + branch + " merged to " + config.local.rootBranch);
        }
        return next(err, branch);
      });
    });
    syncTasks.push(function(branch, next) {
      return git("tag -l", function(err, data) {
        return next(err, branch, data.split("\n"));
      });
    });
    syncTasks.push(function(branch, tags, next) {
      var getTag, tag;
      if (args.tag === false) {
        return next(null, branch, null);
      }
      if (typeof args.tag === "string") {
        tag = args.tag;
      }
      if (tag) {
        return next(null, branch, tag);
      }
      getTag = function() {
        return process.stdout.write("Enter commit tag (press enter to skip): ");
      };
      process.stdin.resume();
      process.stdin.on("data", function(data) {
        tag = data.toString().trim();
        if (!tag.length || __indexOf.call(tags, tag) < 0) {
          return next(null, branch, tag.toString().trim());
        } else {
          console.log(("Tag " + tag.bold + " already exists!").red);
          return getTag();
        }
      });
      return getTag();
    });
    syncTasks.push(function(branch, tag, next) {
      if (!tag) {
        return next(null, branch);
      }
      return git("tag " + tag, function(err) {
        if (!err) {
          console.log("Commit tagged with " + tag + ".");
        }
        return next(err, branch);
      });
    });
    syncTasks.push(function(branch, next) {
      return git("branch -d " + branch, function(err) {
        if (!err) {
          console.log("Deleted branch " + branch + ".");
        }
        return next(err);
      });
    });
    syncTasks.push(function(next) {
      console.log("Done.");
      return next();
    });
    return async.waterfall(syncTasks, cb);
  });

  /*
    gitf update
  */


  task("update", function(args, cb) {
    return getCurrentBranch(function(err, branch) {
      if (err) {
        return cb(err);
      }
      if (branch === config.local.rootBranch) {
        return cb("Cannot update root branch with itself");
      }
      return git("merge --no-ff --no-edit " + config.local.rootBranch, function(err) {
        if (!err) {
          console.log("Done. Branch " + config.local.rootBranch.bold + " merged to " + branch.bold + ".");
        }
        return cb(err);
      });
    });
  });

  /*
    gitf [usage]
  */


  task("usage", function(args, cb) {
    console.log("\n" + "GITFS".bold + " - a simple git dev-flow tool");
    return printUsage(args, cb);
  });

  /*
    gitf config <config_task>
  */


  task("config", function(args, cb) {
    var process, subTask;
    subTask = args._.shift();
    if (subTask === "update") {
      process = exec("curl \"" + config.install.url + "\" | sh ");
      process.stdout.on("data", console.log);
      process.stderr.on("data", console.log);
      return process.on("close", function(code) {
        if (code > 0) {
          return cb("Update failed");
        }
        return cb();
      });
    }
  });

  callback = function(err, data) {
    if (err) {
      if (err.message) {
        err = err.message.trim();
      }
      if (typeof err === "string") {
        process.stderr.write(("ERROR: " + err + " ").redBG.white.bold);
        process.stderr.write("\r\n");
      } else {
        console.log(err);
      }
      printUsage();
      process.exit(1);
    }
    return process.exit(0);
  };

  runTask = function(args, cb) {
    var taskName;
    taskName = args._.shift();
    if (!taskName) {
      taskName = "usage";
    }
    if (!tasks[taskName]) {
      return cb("Task " + taskName + " does not exist!");
    }
    return tasks[taskName](args, cb);
  };

  runTask(argv, callback);

}).call(this);
